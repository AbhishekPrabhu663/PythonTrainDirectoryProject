from flask import Flask, request, render_template, redirect, url_for, flash, jsonify,send_file
from werkzeug.security import generate_password_hash
import sqlite3
import random
import os
from flask_cors import CORS, cross_origin
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import smtplib
import uuid
from datetime import datetime, timedelta
from werkzeug.security import check_password_hash
import firebase_admin
from firebase_admin import credentials, messaging

# Initialize Firebase Admin SDK
cred = credentials.Certificate('C:/Users/nycenagayakshe/Desktop/python/myfirstpythonproject/CapstoneProject/serviceAccountKey.json')
firebase_admin.initialize_app(cred)
# Set environment variables (only needed once, for testing purposes)
os.environ["SENDER_EMAIL"] = "pythonproject743@gmail.com"

#this is the unique password generated by google for the login
os.environ["SENDER_PASSWORD"] = "exoj gocc dzke mcay"

app = Flask(__name__, template_folder="C:/Users/nycenagayakshe/Desktop/python/myfirstpythonproject/CapstoneProject")  # Adjusted template folder
app.secret_key = 'your_secret_key'  # Required for flash messages

# Enable CORS for all routes
CORS(app, resources={r"/*": {"origins": "*"}})


@app.route('/capstone.css')
def serve_css():
    return send_file('C:/Users/nycenagayakshe/Desktop/python/myfirstpythonproject/CapstoneProject/capstone.css')

@app.route('/capstone.js')
def serve_js():
    return send_file('C:/Users/nycenagayakshe/Desktop/python/myfirstpythonproject/CapstoneProject/JS/capstone.js')

@app.route('/register', methods=['POST'])
def register():
    print("Received a registration request")
    # Access the JSON data
    data = request.get_json()
    print("Received data:", data)

    # Extract fields from data
    try:
        full_name = data['full_name']
        email = data['email']
        username = data['username']
        password = data['password']
        confirm_password = data['confirm_password']
        mobile = data['mobile']
    except KeyError as e:
        print("Error: Missing data field", e)
        return jsonify({"success": False, "message": f"Missing field: {e}"}), 400

    # Hash the password before storing it
    hashed_password = generate_password_hash(password)

    # Connect to the database and insert user data
    try:
        conn = sqlite3.connect('BACKUPDB.db')
        cursor = conn.cursor()
        cursor.execute("""
            INSERT INTO newuser (full_name, email, username, password, confirm_password, mobile)
            VALUES (?, ?, ?, ?, ?, ?)
        """, (full_name, email, username, hashed_password, confirm_password, mobile))
        conn.commit()
        print("User registered successfully.")
        return jsonify({"success": True})

    except sqlite3.IntegrityError as e:
        print("Database Integrity Error:", e)
        return jsonify({"success": False, "message": "Username or email already exists."})

    except Exception as e:
        print("Database error:", e)
        return jsonify({"success": False, "message": "An unexpected error occurred."}), 500

    finally:
        conn.close()

# Route for the success page
@app.route('/success')
def success():
    return "Account created successfully!"

# Route for the registration form
@app.route('/register_form')
def register_form():
    return render_template('CreateAnewaccount.html')



# Added 'OPTIONS' to allow CORS preflight
@app.route('/send_reset_link', methods=['POST', 'OPTIONS'])
@cross_origin()
def send_reset_link():
    print("Received a reset link request")
    data = request.get_json()
    email = data.get('email')
    print("Received reset link request:", data)

    if not email:
        return jsonify({"success": False, "message": "Email is required."}), 400

    token = str(uuid.uuid4())
    expires_at = (datetime.now() + timedelta(hours=1)).isoformat()
    try:
        with sqlite3.connect('BACKUPDB.db', timeout=5) as conn:
            cursor = conn.cursor()
            cursor.execute("PRAGMA journal_mode=WAL;")
            cursor.execute("INSERT INTO password_reset (email, token, expires_at) VALUES (?, ?, ?)",
                           (email, token, expires_at))
            conn.commit()

        # Fetch email credentials from environment variables
        sender_email = os.getenv("SENDER_EMAIL")
        sender_password = os.getenv("SENDER_PASSWORD")

        if not sender_email or not sender_password:
            raise ValueError("Sender email or password environment variables not set.")

        # Email sending logic
        subject = "Password Reset Request"
        reset_link = f"http://127.0.0.1:5000/reset_password"
        body = f"Click the link below to reset your password:\n\n{reset_link}\n\nThis link expires in 1 hour."

        msg = MIMEMultipart()
        msg['From'] = sender_email
        msg['To'] = email
        msg['Subject'] = subject
        msg.attach(MIMEText(body, 'plain'))

        with smtplib.SMTP("smtp.gmail.com", 587) as server:
            server.starttls()
            server.login(sender_email, sender_password)
            server.sendmail(sender_email, email, msg.as_string())
            print("Connection and email sending successful.")
        return jsonify({"success": True, "message": "Reset link sent successfully."})

    except smtplib.SMTPAuthenticationError as e:
        print("SMTP Authentication Error:", e)
        return jsonify({"success": False, "message": "Invalid email credentials."}), 500
    except Exception as e:
        print("Error:", e)
        return jsonify({"success": False, "message": "Failed to send reset link."}), 500


#validating the user while loggin in
@app.route('/validate_user', methods=['POST'])
def validate_user():
    data = request.get_json()
    username = data.get('username')
    password = data.get('password')

    try:
        conn = sqlite3.connect('BACKUPDB.db')
        cursor = conn.cursor()

        # Fetch user data from database
        cursor.execute("SELECT password FROM newuser WHERE username = ?", (username,))
        result = cursor.fetchone()
        print(result)  # Debugging output

          # Check if the result is not None
        if result:
            hashed_password = result[0]  # Get the hashed password
            # Validate the user password
            if check_password_hash(hashed_password, password):  # Check the hashed password
                return jsonify({"success": True})
            else:
                return jsonify({"success": False, "message": "Invalid username or password."})
        else:
            return jsonify({"success": False, "message": "Invalid username or password."})

    except Exception as e:
        print("Error:", e)
        return jsonify({"success": False, "message": "An error occurred while validating the user."}), 500

    finally:
        conn.close()

#rendering the password reset template
@app.route('/reset_password',methods=['GET', 'POST'])
def reset_password():
    print("hello inside reset_password")
    try:
        print("Looking for template in:", app.template_folder)
        return render_template('PasswordReset.html')
    except Exception as e:
        print("Error rendering PasswordReset.html:", e)
        return "An error occurred loading the reset page.", 500

# Updating the password
@app.route('/password_update', methods=['POST'])
def password_update():
    print("password update")
    data = request.get_json()
    print("Received data:", data)

    new_password = data.get('newPassword')
    confirm_password = data.get('confirmPassword')
    email = data.get('email')

    # Validate password match
    if new_password != confirm_password:
        return jsonify({"success": False, "message": "Passwords do not match."}), 400

    # Hash the new password
    hashed_password = generate_password_hash(new_password)

    # Retry logic integrated into the function
    retries = 3
    delay = 2

    for attempt in range(retries):
        try:
            with sqlite3.connect('BACKUPDB.db', timeout=5) as conn:
                cursor = conn.cursor()
                cursor.execute("PRAGMA journal_mode=WAL;")

                # Check if the email exists in the newuser table
                cursor.execute("SELECT * FROM newuser WHERE email = ?", (email,))
                user = cursor.fetchone()
                if not user:
                    return jsonify({"success": False, "message": "User not found."}), 404

                # Proceed to update the password if the user exists
                cursor.execute("UPDATE newuser SET password = ? WHERE email = ?", (hashed_password, email))
                conn.commit()

            return jsonify({"success": True, "message": "Password updated successfully."})

        except sqlite3.OperationalError as e:
            if "database is locked" in str(e):
                print(f"Attempt {attempt + 1}/{retries} failed due to database lock. Retrying in {delay} seconds...")
                time.sleep(delay)  # Wait before retrying
            else:
                print("Database error:", e)
                return jsonify({"success": False, "message": "Database error occurred."}), 500
        except Exception as e:
            print("Error:", e)
            return jsonify({"success": False, "message": "An error occurred."}), 500

    # If all retries failed
    return jsonify({"success": False, "message": "Max retries reached. Please try again later."}), 500


# sending the otp
@app.route('/send_otp', methods=['POST'])
def send_otp():
    print("inside send_otp")
    data = request.get_json()
    mobile = data.get('mobile')

    if not mobile:
        return jsonify({"success": False, "message": "Mobile number is required."}), 400

    # Generate a random OTP
    otp = random.randint(100000, 999999)
    print(f"Generated OTP: {otp}")

    try:
        created_at = datetime.now().isoformat()  # Create the datetime object and call isoformat() on it
        with sqlite3.connect("BACKUPDB.db") as conn:
            cursor = conn.cursor()
            cursor.execute("INSERT INTO otp_verification (mobile, otp, created_at) VALUES (?, ?, ?)",
                           (mobile, otp, created_at))
            conn.commit()

        # Send OTP via Firebase Authentication
        message = messaging.Message(
            data={
                'otp': str(otp),
                'mobile': mobile
            },
            token=mobile,  # This should be the Firebase Messaging token for the mobile number
        )
        # Send a message to the device corresponding to the provided registration token
        response = messaging.send(message)
        print(f"Sent message: {response}")  # Optional for debugging

        return jsonify({"success": True, "message": "OTP sent."})
    except Exception as e:
        print(f"Error: {e}")
        return jsonify({"success": False, "message": str(e)}), 500

# Running the app
if __name__ == '__main__':
    app.run(debug=True)
